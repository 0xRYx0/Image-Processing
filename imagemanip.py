# -*- coding: utf-8 -*-
"""imageManip
Automatically generated by Colaboratory.

## Image Manipulation
This set of function are developed to manipulate images using well-known image processing techniques
"""

# Commented out IPython magic to ensure Python compatibility.
import cv2
import random 
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

# %matplotlib inline
plt.rcParams['figure.figsize'] = (10.0, 8.0)        # set default size of plots
plt.rcParams['image.interpolation'] = 'nearest'
plt.rcParams['image.cmap'] = 'gray'


# This method is used to display an input image in 5x5 figure with no axis
def displayImage(image):
    plt.figure(figsize = (5,5))
    plt.imshow(image)
    plt.axis('off')
    plt.show()


# This method is used to read an input image and displayit using [displayImage] method 
def readImage(imagePath):
    image = mpimg.imread(imagePath)
    displayImage(image)
    return image


# This method is used to convert an input image into different color system:
def convertColor(image, srcColor, targetColor):

    # Converting image from RBG to HSV
    if (srcColor == 'RGB'and targetColor == 'HSV'):
        converted_Image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
        converted_Image = cv2.cvtColor(converted_Image, cv2.COLOR_BGR2HSV)
        return converted_Image

    # Converting image from RBG to GREY
    elif (srcColor== 'RGB'and targetColor == 'GREY'):
        converted_Image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
        return converted_Image

    # Converting image from RBG to Black and White
    elif (srcColor== 'RGB'and targetColor == 'BW'):
        converted_Image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        (thresh, converted_Image) = cv2.threshold(converted_Image, 127, 255, cv2.THRESH_BINARY)
        return converted_Image


# This method is used to decompose an input image into R, G and B channels and return the image excluding the specified channel
def rgb_exclusion(image, channelToExclude):

    copy_img = image.copy()

    # Excludind "Blue" channel
    if (channelToExclude == 'B'):
        copy_img[:,:,0] = 0
        return copy_img

    # Excludind "Green" channel
    elif (channelToExclude == 'G'):
        copy_img[:,:,1] = 0
        return copy_img

    # Excludind "Red" channel
    elif (channelToExclude == 'R'):
        copy_img[:,:,2] = 0
        return copy_img


# This method is used to decompose an input image into H, S and V channels and return the image excluding the specified channel
def hsv_decomposition(image, channelToExclude):
    hsv_img = image.copy()
    hsv_img = convertColor(image, 'RGB', 'HSV')
    copy_img = hsv_img.copy()

    # Excludind "Hue" channel
    if (channelToExclude == 'H'):
        copy_img[:,:,0] = 0
        return copy_img, hsv_img

    # Excludind "Saturation" channel
    elif (channelToExclude == 'S'):
        copy_img[:,:,1] = 0
        return copy_img

    # Excludind "Value" channel
    elif (channelToExclude == 'V'):
        copy_img[:,:,2] = 0
        return copy_img


# This method is used to traansform an input image into Frequency Domain and calculate image's real, imaginary, magnitude and phase parts
def fourier_tranformer(image):
    # Original Image on gray scale:
    img_org = convertColor(image, 'RGB', 'GREY')

    # Image's Magnitude Spectrum
    ft = np.fft.fft2(img_org)                   # 2-dimensional discrete Fourier Transform
    shifted_ft = np.fft.fftshift(ft)            # Shift the zero-frequency component to the center of the spectrum.
    real = shifted_ft.real                      # Image's Real Part
    imaginary = shifted_ft.imag                 # Image's Imaginary Part
    phase = np.angle(shifted_ft)                # Image's Phase
    magnitude = np.log(1+np.abs(shifted_ft))    # Image's Magnitude
    return real, imaginary, magnitude, phase


# This method is used to add a noise to an input image by specifying Noise Type and Size
def add_noise(image, noiseType, size):
    noisy_img = convertColor(image, 'RGB', 'GREY')
    row,col = noisy_img.shape
    
    # Salt and Pepper noise
    if noiseType == 'salt':
        for p in range(1,int(row*col*size)): 
            noisy_img[random.randint(0,row-1)][random.randint(0,col-1)] = 255       # White pixel
            noisy_img[random.randint(0,row-1)][random.randint(0,col-1)] = 0         # Black pixel 
        print('Pixel count: ', int(row*col))
        print('Salted Pixels: ', int(row*col*size))        
        return noisy_img 
    
    # Gaussian noise
    if noiseType == 'gaussian':
        gaussian = np.random.normal(0,size*10,(row,col))        # Mean & Standard Deviation
        gaussian = gaussian.reshape(row,col)
        noisy_img = noisy_img + gaussian
        print('Sigma = ',size*10)
        return noisy_img

# This method is used to apply iamage by specifying Filter Type and Size
def filters(image, filterType, size):

    # Applying Mean Filtter
    if filterType == 'average':
        kernel = np.ones((size,size),np.float32)/size**2
        filtered_img = cv2.filter2D(image,-1,kernel)
        return filtered_img

    # Applying Median Filtter
    if filterType == 'median':
        filtered_img = cv2.medianBlur(image,size)
        return filtered_img 

    # Applying Gaussian Fillter
    if filterType == 'gaussian':
        filtered_img = cv2.GaussianBlur(image,(size,size),0)
        return filtered_img 


def plot_fig(image_list,src_image):
    f, axs = plt.subplots(1,7,figsize=(30,30))
    plt.subplot(171),plt.imshow(src_image),plt.title('Original Image')
    plt.xticks([]), plt.yticks([])
    plt.subplot(172),plt.imshow(image_list[0]),plt.title('Filter: Average 3')
    plt.xticks([]), plt.yticks([])
    plt.subplot(173),plt.imshow(image_list[1]),plt.title('Filter: Average 5')
    plt.xticks([]), plt.yticks([])
    plt.subplot(174),plt.imshow(image_list[2]),plt.title('Filter: Gaussian 3')
    plt.xticks([]), plt.yticks([])
    plt.subplot(175),plt.imshow(image_list[3]),plt.title('Filter: Gaussian 5')
    plt.xticks([]), plt.yticks([])
    plt.subplot(176),plt.imshow(image_list[4]),plt.title('Filter: Median 3')
    plt.xticks([]), plt.yticks([])
    plt.subplot(177),plt.imshow(image_list[5]),plt.title('Filter: Median 5')
    plt.xticks([]), plt.yticks([])
    plt.show()


# This methoed is used to enhance an input image using Power-Law Transformation and display the enhanced image
def power_trans(image, display_plot: bool):
    processed_image = []
    gamma = [0.1, 0.5, 1.2, 2.2]
    for g in gamma:
        gamma_corrected = np.array(255*(image / 255) ** g, dtype = 'uint8') 
        processed_image.append(gamma_corrected)

    if display_plot:
        f, axs = plt.subplots(1,5,figsize=(30,30))
        plt.subplot(151),plt.imshow(image),plt.title('Original Image')
        plt.xticks([]), plt.yticks([])
        plt.subplot(152),plt.imshow(processed_image[0]),plt.title('gamma: %0.2f'%gamma[0])
        plt.xticks([]), plt.yticks([])
        plt.subplot(153),plt.imshow(processed_image[1]),plt.title('gamma: %0.2f'%gamma[1])
        plt.xticks([]), plt.yticks([])
        plt.subplot(154),plt.imshow(processed_image[2]),plt.title('gamma: %0.2f'%gamma[2])
        plt.xticks([]), plt.yticks([])
        plt.subplot(155),plt.imshow(processed_image[3]),plt.title('gamma: %0.2f'%gamma[3])
        plt.xticks([]), plt.yticks([])
        plt.show();
    return processed_image

# This methoed is used to enhance an input image using Histogram Equalization and display the enhanced image
def hist_equalizer(image, display_plot: bool):
    filtered_img = convertColor(image, 'RGB', 'GREY')
    filtered_img = cv2.equalizeHist(filtered_img)
    if display_plot:
        plt.subplot(121),plt.imshow(image),plt.title('Original Image')
        plt.xticks([]), plt.yticks([])
        plt.subplot(122),plt.imshow(filtered_img),plt.title('Histogram Equalization')
        plt.xticks([]), plt.yticks([])
        plt.show();
    return filtered_img
